<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>OOP</title>
	</head>
	<body>
		<script type="text/javascript">
			
			function Cat(name,color){
				this.name = name;
				this.color = color;
			}
			Cat.prototype.type = "猫科动物";
			Cat.prototype.eat = function(){console.log("吃老鼠")};
			//每一个构造函数都有一个prototype属性，指向另一个对象。可以把那些不变的属性和方法，直接定义在prototype对象上
			
			var cat1 = new Cat("大毛","黑色");
			var cat2 = new Cat("二毛","白色");
			
			console.log(cat1,cat2);
			console.log(cat1.constructor == Cat); //true
			console.log(cat2.constructor == Cat); //true
			//自动含有一个constructor属性，指向它们的构造函数。
			
			cat1.eat(); //"吃老鼠"
			cat2.eat(); //"吃老鼠"
			
			console.log(cat1.eat == cat2.eat); //true
			//实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。
			
			console.log(Cat.prototype.isPrototypeOf(cat1)) //true
			console.log(Cat.prototype.isPrototypeOf(cat2)) //true
			//用来判断，某个proptotype对象和某个实例之间的关系。
			
			console.log(cat1.hasOwnProperty("name")); //true
			console.log(cat1.hasOwnProperty("type")); //false
			//hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。
		</script>
	</body>
</html>
